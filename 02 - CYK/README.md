# Application of Cocke–Younger–Kasami (CYK) algorithm

Here is my implementation of a parser that determines whether a given word belongs to a language defined by a given context-free grammar (CFG) in Chomsky Normal Form (CNF). If the word is part of the language, the parser provides a derivation of the word using the rules of the grammar.

## Task Description

During an archaeological exploration, clay tablets with mysterious texts were discovered. Each tablet appears to be written in a different language. Professors at a university have taken on the challenge of determining which language corresponds to the texts on each tablet. They have compiled possible grammars representing these languages, formalized using specific grammatical rules.

To facilitate automatic processing, the grammars are standardized in the following form:

- **Grammar Rules**:
    - The left side of a rule can be rewritten into either:
        - Two non-terminals (binary production), or
        - One terminal (unit production).
    - To generate the empty word (epsilon), a rule that rewrites the initial non-terminal to nothing is allowed, but in this case, the initial non-terminal must not appear on the right side of any rule.

The task is to implement a program that decides whether a given word belongs to the language represented by such a grammar. If the word is part of the language, the program must also find a derivation of the word according to the grammar's rules.

### Function Signature

The core function to implement is:

```cpp
std::vector<size_t> trace(const Grammar& g, const Word& w);
```

- **Input**:
    - `Grammar g`: The CFG representing the language.
    - `Word w`: The word to be tested for membership in the language.
- **Output**:
    - If the word belongs to the language:
        - Return a sequence of rule indices (from `g.m_Rules`) that derive the word using a leftmost derivation.
    - If the word does not belong to the language:
        - Return an empty vector.

### Constraints

- **Grammar Validity**:
    - The sets of terminals (`g.m_Terminals`) and non-terminals (`g.m_Nonterminals`) do not intersect.
    - All rules contain symbols from these two sets.
    - Rules are in the specified form (binary or unit productions, or epsilon production for the initial symbol).
    - The initial symbol is included in the set of non-terminals.
    - There are no duplicate rules.

- **Symbols**:
    - Symbols in the grammar and word are of type `char`.

## Solution Overview

The solution implements the **Cocke–Younger–Kasami (CYK) algorithm**, a classic parsing algorithm for CFGs in CNF. The algorithm determines whether a word can be generated by the grammar and constructs a parse table to facilitate derivation reconstruction.

### Key Components

- **Parsing Table (`Table`)**:
    - A two-dimensional table where each cell `T[i][j]` contains possible non-terminals (represented by rule indices) that can generate the substring `w[i..i+j]`.
    - Cells also store predecessor information to reconstruct the derivation path.

- **Rule Indices**:
    - Instead of storing non-terminal symbols directly, the implementation stores the indices of the rules that produce those non-terminals.
    - This facilitates tracking the exact rules used during parsing for derivation reconstruction.

- **Derivation Reconstruction**:
    - After filling the parsing table, if the initial symbol is present in `T[0][n-1]` (where `n` is the length of the word), the algorithm backtracks through the table to reconstruct the sequence of rule applications.

### Steps

1. **Initialization**:
    - Handle the special case where the word is empty:
        - Check if the grammar allows generating the empty word (epsilon).
        - If so, return the index of the epsilon rule.
        - If not, return an empty vector.
    - Initialize the parsing table `T` as a vector of vectors of cells.

2. **Filling the Parsing Table**:
    - **Length 1 Substrings**:
        - For each position `i` in the word, find all rules that produce the terminal `w[i]`.
        - Populate `T[i][0]` with these rule indices.
    - **Longer Substrings**:
        - For lengths `j` from 1 to `n-1`:
            - For each starting position `i`:
                - For each split position `l`:
                    - Combine non-terminals from `T[i][l]` and `T[i+l+1][j-l-1]` to form pairs.
                    - For each pair, find all rules that produce the pair of non-terminals.
                    - Populate `T[i][j]` with these rule indices and store predecessor information.

3. **Derivation Reconstruction**:
    - If the initial symbol is present in `T[0][n-1]`, begin backtracking:
        - Use a stack to keep track of positions and rule indices.
        - Pop entries from the stack and push predecessors until the entire derivation is reconstructed.
    - Collect the sequence of rule indices used in the derivation.

4. **Result**:
    - Return the sequence of rule indices corresponding to a leftmost derivation of the word.
    - If the word cannot be derived, return an empty vector.

### Files Structure

```
.
├── .gitignore
├── .gitkeep
├── README.md
└── sample.cpp
```

- **`.gitignore`**: Specifies files and directories to be ignored by Git.
- **`.gitkeep`**: An empty file to ensure Git tracks the otherwise empty directory.
- **`README.md`**: This file, containing the task description and solution overview.
- **`sample.cpp`**: Contains the C++ implementation of the `trace` function and supporting code.

### Notes

- **Grammar Representation**:
    - The grammar is expected to be in Chomsky Normal Form (CNF).
    - Symbols are of type `char`, and terminals and non-terminals are distinguished based on their inclusion in `g.m_Terminals` or `g.m_Nonterminals`.

- **Algorithm Limitations**:
    - The CYK algorithm requires the grammar to be in CNF.
    - The implementation may not work correctly for grammars that do not adhere to CNF.

- **Performance**:
    - The algorithm has a time complexity of $ O(n^3 \cdot |G|) $, where $ n $ is the length of the word and \( |G| \) is the size of the grammar.
    - Suitable for relatively short words and grammars.


### References

- **Cocke–Younger–Kasami (CYK) Algorithm**:
    - A parsing algorithm for context-free grammars in CNF.
    - Useful for determining whether a string can be generated by a grammar and for parsing in computational linguistics.

- **Chomsky Normal Form (CNF)**:
    - A form of CFG where all production rules are either:
        - $ A \rightarrow BC $ (where $ A, B, C $ are non-terminals), or
        - $A \rightarrow a $ (where $ a $ is a terminal), or
        - $ S \rightarrow \epsilon $ (only if $ S $ does not appear on the right-hand side of any rule).
